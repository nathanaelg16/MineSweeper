package com.nathanaelg.cmp168.minesweeper;

import javafx.scene.control.Button;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;

import java.util.HashMap;
import java.util.Objects;
import java.util.ResourceBundle;

/**
 * A subclass of the {@link Button} class
 * that represents a cell in the {@link BombGrid}
 * generated by the game.
 * <p>
 * The {@link Cell} holds information about
 * the specific location in the BombGrid, including
 * the row and column indices, whether it has a bomb
 * or not, and the count at that location.
 * <p>
 * The Cell class also handles the revealing of the
 * contents of the cell when clicked. If it is a bomb,
 * then a bomb is revealed. If not, the count at the location
 * is clicked.
 * <p>
 * The Cell class can also toggle showing a flag at the cell
 * to indicate that the user believes there is a bomb at this
 * location. When the flag is toggled on, cells are not revealed until
 * the game is over or until the flag is toggled back off.
 */
public class Cell extends Button {
    private final int row;
    private final int column;
    private final int count;
    private final boolean hasBomb;

    /**
     * Image of a flag
     */
    private static final Image flagImage = new Image(Objects.requireNonNull(ClassLoader.getSystemResourceAsStream("resources/images/flag-100x.png")));
    /**
     * Image of a bomb
     */
    private static final Image bombImage = new Image(Objects.requireNonNull(ClassLoader.getSystemResourceAsStream("resources/images/bomb-100x.png")));
    /**
     * Contains the colors that correspond to each possible
     * number in the count of each cell. Colors are predetermined
     * and read from a property file. The keys of the map are integers
     * from 0-9 which are the only possible values a cell count can have.
     *
     * @see BombGrid#getCountAtLocation(int, int)
     */
    private static HashMap<Integer, Paint> colors;
    /**
     * The number of cells that have been revealed since the game begun.
     * This value is reset to zero by calling {@link Cell#resetNumCellsRevealed()}.
     * This method is called every time a new game is begun.
     */
    private static int numCellsRevealed = 0;
    private final ImageView imageView; //used to display either bomb or flag image
    private boolean isRevealed; //whether the cell has been revealed or not
    private boolean hasFlag; //whether the cell has a flag on it or not

    /**
     * Creates a new Cell with the given values for
     * row index, column index, count at location, and
     * whether a bomb exists at this location or not.
     * <p>
     * The count at location represents the number of
     * bombs surrounding the given cell, including the
     * cell itself.
     *
     * @param row     row index of the cell
     * @param column  column index of the cell
     * @param count   the number of bombs surrounding the cell,
     *                including the cell itself
     * @param hasBomb true if the cell contains a bomb
     * @see BombGrid#getCountAtLocation(int, int)
     */
    public Cell(int row, int column, int count, boolean hasBomb) {
        super();
        if (colors == null) init();
        this.row = row;
        this.column = column;
        this.count = count;
        this.hasBomb = hasBomb;
        this.isRevealed = false;
        this.imageView = new ImageView();
        this.imageView.fitWidthProperty().bind(this.widthProperty().multiply(0.60));
        this.imageView.setFitHeight(this.getHeight() * 0.80);
        this.imageView.setPreserveRatio(true);
        this.getStyleClass().add("cell");
    }

    /**
     * Initializes the hash map by reading from the properties file
     * containing the hex colors to be used by the numbers in the game.
     * This method is only called once by the Cell constructor if
     * the colors hash map has not been initialized or is null.
     */
    private static void init() {
        ResourceBundle colorsBundle = ResourceBundle.getBundle("resources/bundles/colors");
        colors = new HashMap<>();
        colors.put(0, Color.web(colorsBundle.getString("zero")));
        colors.put(1, Color.web(colorsBundle.getString("one")));
        colors.put(2, Color.web(colorsBundle.getString("two")));
        colors.put(3, Color.web(colorsBundle.getString("three")));
        colors.put(4, Color.web(colorsBundle.getString("four")));
        colors.put(5, Color.web(colorsBundle.getString("five")));
        colors.put(6, Color.web(colorsBundle.getString("six")));
        colors.put(7, Color.web(colorsBundle.getString("seven")));
        colors.put(8, Color.web(colorsBundle.getString("eight")));
        colors.put(9, Color.web(colorsBundle.getString("nine")));
    }

    /**
     * Gets the number of cells revealed through the game
     *
     * @return number of cells revealed throughout the game
     */
    public static int getNumCellsRevealed() {
        return numCellsRevealed;
    }

    /**
     * Resets the number of cells revealed to 0.
     */
    public static void resetNumCellsRevealed() {
        numCellsRevealed = 0;
    }

    /**
     * Reveals the contents of the cell.
     * <p>
     * If the cell contains a bomb, the bomb is revealed
     * by changing the graphic of the cell to depict the image
     * of a bomb.
     * <p>
     * Otherwise, this cell's count is shown.
     * <p>
     * NOTE: If this cell has a flag, the method will return without
     * revealing anything.
     * <p>
     * NOTE: If this cell has already been revealed, this method will do
     * nothing
     */
    public void reveal() {
        if (this.hasFlag || this.isRevealed) return; //do nothing if has flag or has been revealed
        if (this.hasBomb) revealBomb();
        else this.revealCount();
        this.isRevealed = true;
        numCellsRevealed++;
    }

    /**
     * Reveal the number of bombs surrounding the cell.
     */
    private void revealCount() {
        this.setText(String.valueOf(this.count));
        this.setTextFill(colors.get(this.count));
    }

    /**
     * Reveal that there is a bomb in this cell only if this
     * cell has a bomb.
     */
    private void revealBomb() {
        if (!this.hasBomb) return;
        this.imageView.setImage(bombImage);
        this.setGraphic(imageView);
    }

    /**
     * Gets the count at location
     *
     * @return the number of cells with bombs surrounding this location
     */
    public int getCount() {
        return count;
    }

    /**
     * Determines whether this cell has a bomb or not.
     *
     * @return true if this cell has a bomb
     */
    public boolean hasBomb() {
        return hasBomb;
    }

    /**
     * Determines whether this cell has been revealed.
     *
     * @return true if the cell has not been revealed,
     * false if the cell has been revealed.
     * @see Cell#reveal()
     */
    public boolean isHidden() {
        return !isRevealed;
    }

    /**
     * Gets the row index of this cell.
     *
     * @return row index of the cell
     */
    public int getRow() {
        return row;
    }

    /**
     * Gets the column index of this cell.
     *
     * @return column index of the cell
     */
    public int getColumn() {
        return column;
    }

    /**
     * Determines whether this cell is
     * showing a flag or not
     *
     * @return true if this cell is showing
     * the image of a flag
     */
    public boolean hasFlag() {
        return hasFlag;
    }

    /**
     * If the cell has not been revealed,
     * this method will show a flag if there isn't one,
     * otherwise the existing flag is removed.
     */
    public void toggleFlag() {
        if (!isHidden()) return;
        imageView.setImage(flagImage);
        if (!hasFlag) this.setGraphic(imageView);
        else this.setGraphic(null);
        this.hasFlag = !this.hasFlag;
    }
}